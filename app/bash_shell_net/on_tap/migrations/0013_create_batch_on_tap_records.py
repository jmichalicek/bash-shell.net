# Generated by Django 5.2.1 on 2025-05-31 20:36

from django.db import migrations


def forwards_func(apps, schema_editor):
    BatchLogPage = apps.get_model("on_tap", "BatchLogPage")
    BatchOnTapRecord = apps.get_model("on_tap", "BatchOnTapRecord")
    db_alias = schema_editor.connection.alias

    for page in BatchLogPage.objects.using(db_alias).exclude(on_tap_date=None):
        BatchOnTapRecord.objects.using(db_alias).get_or_create(
            batch_log_page=page,
            on_tap_date=page.on_tap_date,
            off_tap_date=page.off_tap_date,
        )

    # One off specific fixes
    for page in BatchLogPage.objects.filter(pk__in=[158, 184]):
        if not BatchOnTapRecord.objects.filter(batch_log_page=page).exists():
            BatchOnTapRecord.objects.create(batch_log_page=page, never_on_tap=True)


def reverse_func(apps, schema_editor):
    BatchOnTapRecord = apps.get_model("on_tap", "BatchOnTapRecord")
    db_alias = schema_editor.connection.alias

    # ignoring that the schema allows for multiple on tap records, because sometimes I split batches
    # becuse the initial data when these migrations run (and really, I won't ever reverse it anyway)
    # there will only be one record per batch log.
    for record in (
        BatchOnTapRecord.objects.using(db_alias)
        .order_by("on_tap_date", "-off_tap_date")
        .select_related("batch_log_page")
    ):
        record.batch_log_page.on_tap_date = record.on_tap_date
        record.batch_log_page.off_tap_date = record.off_tap_date
        record.batch_log_page.save(update_fields=["on_tap_date", "off_tap_date"])


class Migration(migrations.Migration):

    dependencies = [
        ("on_tap", "0012_alter_batchlogpage_status_and_more"),
    ]

    operations = [
        migrations.RunPython(forwards_func, reverse_func),
    ]
